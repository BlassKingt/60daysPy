Try Learning Test Development from an AI for 60 Days

First, let's talk about the context. My ultimate goal is to find a test development role that's right for me.

However, my current work experience is mixed and unrefined, so I need to learn some solid knowledge—at least, to be able to pass interviews.

So I tried to talk to the AI ​​about my predicament, and ultimately came to the following conclusions:
1. Learn while looking for opportunities.
2. Learning Content: Python scripting, the pytest framework, shell scripting, and Selenium. Automated testing is probably the most relevant to test development job search keywords without hardware, and the content is also quite general.
3. I didn't want to sign up for a class for two reasons: I couldn't customize it in detail; and I didn't want to be ripped off and then give up halfway through after paying tuition. Since I had the context after discussing it with the AI, I decided to use it to customize my study plan and design the content.

The result of diving in headfirst was that I had too much content on the first day! After trying it myself, I realized I couldn't learn it all. Coincidentally, I came across an article about how to set up an AI personal trainer (thanks to the blogger! http://xhslink.com/n/6zg4byoxVy). It felt like a revelation. The blogger's method, in general, is to gradually improve by identifying your capabilities.
Of course, there were some areas that needed adjustment in actual use. For example, I provided a fairly detailed description of my learning needs and plan, which could lead the AI ​​trainer to cramming the content into me, or even giving me the final answers to the exercises.
But for me, learning while doing is probably the best approach, allowing me to apply what I learned immediately and deepen my memory.
I provided these requirements to the AI, and it ultimately summarized this method as follows:

The puzzle learning method, specifically:

1. Each day, set a practice goal for the day → let me know what gadget I'll be building for the final exercise.

2. Break down the functionality → break the goal down into smaller components, with 1–3 small exercises for each component.
3. Practice these small parts → I built them myself.
4. Finally, assemble the parts → Complete today's final exercise (a small tool).

This way, I wasn't bombarded with a mountain of syntax all at once. Instead, I mastered and assembled them piece by piece, like building blocks.
In addition, I added a few details:
1. The introduction of small functions should be more systematic—not just "tell me what it does," but also provide the most common parameters and usage, so I have a "tool manual" in mind.
2. Each function should have multiple progressive small exercises—first confirm the most basic usage, then go through small exercises with different parameters, so I can actively choose the correct writing method.
3. Small functions should be linked together—daily goals shouldn't be too simplistic; instead, small functions should be gradually integrated, ultimately producing a "slightly interesting small tool."
